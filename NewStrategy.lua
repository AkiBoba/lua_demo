---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yo114.
--- DateTime: 21.02.2024 20:51
---

stopped = false

function OnStop()
    stopped = true
    --killAllOrders()
    myLog('\nfinished ')
    return 10000
end

FILE_LOG_NAME = "C:\\TRADING\\new_str_SiH.txt"
g_previous_time = os.time() -- помещение в переменную времени сервера в формате HHMMSS
FIRM_ID = 'SPBFUT000000'
ACCOUNT = 'SPBFUT000zt'
CLIENT_CODE = 'SPBFUT000zt'
CLASS_CODE = 'SPBFUT'
--SEC_CODE = 'BRZ3'
SEC_CODE = 'SiH4'
roundVar = 0
SEC_PRICE_STEP = getParamEx(CLASS_CODE, SEC_CODE, 'SEC_PRICE_STEP').param_value --Минимальный шаг цены
LOT_SIZE = getParamEx(CLASS_CODE, SEC_CODE, 'LOTSIZE').param_value --Размер лота
STEP_PRICE = getParamEx(CLASS_CODE, SEC_CODE, 'STEPPRICE').param_value --Стоимость шага цены
lastMoney = getFuturesLimit(FIRM_ID, CLIENT_CODE,  0, "SUR").cbplplanned
operation = nil
newOrderId = 10000
newStopOrderId = 20000
newTakeProfitOrderId = 30000
KillStopOrderId = 40000
quantity = '1' --количество лот для заказов
--свечи
beforeLastCandleClose = 0 --закрытие предпоследней свечи
beforeBeforeLastCandleClose = 0 --закрытие пред-пред последней свечи
lastCandleClose = 0 --закрытие посл свеча
beforeLastCandleOpen = 0 --открытие предпоследней свечи
beforeBeforeLastCandleOpen = 0 --открытие пред-пред последней свечи
lastCandleOpen = 0 --открытие посл свеча
beforeLastCandleHi = 0 --максимум предпоследней свечи
beforeLastCandleLow = 0 --минимум предпоследней свечи
--переменные ордеров и сделок
futuresClientHolding = 0 --количество лот тек чист поз
lastTradePriceUser = 0 --цена последней сделки
lastStopOrderId = 0 --номер последнего стоп ордера
firstStopOrderPrice = 0 --цена последнего стоп ордера
priceForGetProfit = 0
operationForCheck = nil
--таблицы для определения тренда цены в различных тайм-фреймах
ave_price = 0
Table05MinutePrice = {}
Table01MinutePrice = {}
Table1HPrice = {}
Table1DPrice = {}
TableOfCandles = {}
--переменные для таблицы бота
TableInWindow = AllocTable()
CountOfOrders = 0
CountOfLines = 0
timeFrom = {}
timeTo = {}


function main()
    if checkTime(10, 0, 0) == false then
        sleep(60000)
    else
        while stopped ~= true do
            operation = nil
            message('get operation')
            getOperation()
            if operation ~= nil then
                message('send new order')
                --sendNewOrder()
            end
            sleep(200)
            getItemsFromFuturesClientHolding()
            getLastUserTradePrice()
            insertInTableCloseOrder()    --добавление информации о закрытии позиции
        end
    end
end

--подготовка информационной таблицы
function CreateInfoTable()
    AddColumn(TableInWindow, 1,"Date", true, QTABLE_DATE_TYPE, 10)
    AddColumn(TableInWindow, 2,"TimeEnter", true, QTABLE_TIME_TYPE, 10)
    AddColumn(TableInWindow, 4,"Price", true, QTABLE_INT_TYPE, 10)
    AddColumn(TableInWindow, 5,"TimeExit", true, QTABLE_TIME_TYPE, 10)
    AddColumn(TableInWindow, 6,"Price", true, QTABLE_INT_TYPE, 10)
    AddColumn(TableInWindow, 7,"Profit", true, QTABLE_INT_TYPE, 10)

    CreateWindow(TableInWindow)									-- функция создает окно таблицы по указанному идентификатору
    SetWindowCaption(TableInWindow, "Table of parameters USD")		-- функция прописывает заголовок окна таблицы по указанному идентификатору
    SetWindowPos(TableInWindow, 0, 0, 480, 140)				-- функция задает координаты в пикселях верхнего левого и нижнего правого угла окна таблицы
end

function OnInit()
    f = io.open(FILE_LOG_NAME, "a+") -- открывает файл
    CreateInfoTable()
    myLog("Money in open " .. lastMoney)
end

--проверяем время, что бы скрипт начал работать после 10 утра
function checkTime(hour, min, sec)
    currentDateTime = os.time()
    datetime = os.date("!*t", currentDateTime)
    datetime.hour = hour
    datetime.min = min
    datetime.sec = sec
    return  currentDateTime > os.time(datetime)
end

--получаем тип (продажа - покупка) операции для входа в сделку
function getOperation()
    while operation == nil do
        sleep(1000)
        getTrendForNewOrder()
    end
end

--получаем направление тренда для создания нового ордера
function getTrendForNewOrder()
    createTables()
    if (            redLineOverGreen(Table1HPrice)
                    --and trendIsUp(Table1DPrice)
                    and candleOverLine(createTablesOfCandles(INTERVAL_H1), Table1HPrice)
    ) then
        operation = 'B'
    end
    if (            redLineOverGreen(Table1HPrice) == false
                    --and trendIsUp(Table1DPrice) == false
                    and candleOverLine(createTablesOfCandles(INTERVAL_H1), Table1HPrice) == false
    ) then
        operation = 'S'
        message(tostring(operation))
    end
end

function createTables()

    getAvePrice(INTERVAL_M5, 200, 0)
    Table05MinutePrice['ave_price_green'] = ave_price
    getAvePrice(INTERVAL_M5, 50, 0)
    Table05MinutePrice['ave_price_red'] = ave_price

    getAvePrice(INTERVAL_M1, 36, 0)
    Table01MinutePrice['ave_price_green'] = ave_price
    getAvePrice(INTERVAL_M1, 18, 0)
    Table01MinutePrice['ave_price_red'] = ave_price

    getPricesByCandles(INTERVAL_D1)
    Table1DPrice['lastCandleOpen'] = lastCandleOpen
    Table1DPrice['beforeLastCandleOpen'] = beforeLastCandleOpen
    Table1DPrice['beforeBeforeLastCandleOpen'] = beforeBeforeLastCandleOpen
    Table1DPrice['lastCandleClose'] = lastCandleClose
    Table1DPrice['beforeLastCandleClose'] = beforeLastCandleClose
    Table1DPrice['beforeBeforeLastCandleClose'] = beforeBeforeLastCandleClose

    getAvePrice(INTERVAL_H1, 36, 0)
    Table1HPrice['ave_price_green'] = ave_price
    getAvePrice(INTERVAL_H1, 18, 0)
    Table1HPrice['ave_price_red'] = ave_price
end

function createTablesOfCandles(INTERVAL)
    getPricesByCandles(INTERVAL)
    TableOfCandles['lastCandleOpen'] = lastCandleOpen
    TableOfCandles['beforeLastCandleOpen'] = beforeLastCandleOpen
    TableOfCandles['beforeBeforeLastCandleOpen'] = beforeBeforeLastCandleOpen
    TableOfCandles['lastCandleClose'] = lastCandleClose
    TableOfCandles['beforeLastCandleClose'] = beforeLastCandleClose
    TableOfCandles['beforeBeforeLastCandleClose'] = beforeBeforeLastCandleClose
    return TableOfCandles
end

--ф-я определения среднего значения цены по параметрам
function getAvePrice(INTERVAL, N, Candles)
    --myLog('getAvePrice')
    local data=CreateDataSource(CLASS_CODE,SEC_CODE,INTERVAL);
    --data:SetEmptyCallback()
    i=0;
    while ((i<100)and((data.Size()==0)))do --ожидаем получения данных по свечам.
        i=i+1
        sleep(100);
    end
    if (data) then --данные свечи получены.
        local countOfCandles = data:Size() - Candles -- узнаем количество свечей.
        sumOfMultiPriceAndVol = 0; -- сюда положим сумму произведений цен на объем.
        sum_volume = 0; -- сюда положим сумму объемов.
        for i=countOfCandles,(countOfCandles - N + 1),-1 do --проходимся по свечам от последней. Всего N свечей рассматриваем.
            local closeCurrentCandle = data:C(i)
            local volumeCurrentCandle = data:V(i)
            --myLog("Данные по свече № "..i.." Закрытие: "..closeCurrentCandle.."; Объем:"..volumeCurrentCandle);
            sumOfMultiPriceAndVol = sumOfMultiPriceAndVol + closeCurrentCandle * volumeCurrentCandle; -- суммируем произведение цены на объем.
            sum_volume = sum_volume + volumeCurrentCandle;
        end
        ave_price = sumOfMultiPriceAndVol / sum_volume; -- рассчитываем среднюю цену.
        --myLog ("Средняя цена по последним "..N.." свечам составляет "..ave_price);
    end
end

--Находим значения цен по свечам
function getPricesByCandles(INTERVAL)
    data = CreateDataSource(CLASS_CODE, SEC_CODE, INTERVAL)
    -- data:SetEmptyCallback()
    i=0
    while ((i<100)and((data.Size()==0))) do --ожидаем получения данных по свечам.
        i=i+1
        sleep(100);
    end
    if (data) then --данные свечи получены.
        countCandles = data:Size() -- узнаем количество свечей.
        beforeLastCandleClose = data:C(countCandles-1)
        beforeBeforeLastCandleClose = data:C(countCandles-2)
        LastCandleClose = data:H(countCandles) -- полседняя цена текущий свечи
        LastCandleLow = data:L(countCandles)
        beforeLastCandleHi = data:H(countCandles-1)
        beforeLastCandleLow = data:L(countCandles-1)
    end
end

--проверяем что свеча растет
function candleRise(tableOfCandles)
    if (tableOfCandles['beforeLastCandleClose'] > tableOfCandles['beforeLastCandleOpen']) then
        return true
    else if (tableOfCandles['beforeLastCandleClose'] < tableOfCandles['beforeLastCandleOpen']) then
        return false
    end
    end
end

--проверяем что быстрая средняя линия над медленной
function redLineOverGreen(table)
    if (table['ave_price_red'] > table['ave_price_green']
            --and table['ave_price_red_before'] < table['ave_price_green_before']
    ) then
        return true
    else if (table['ave_price_red'] < table['ave_price_green']
            --and table['ave_price_red_before'] > table['ave_price_green_before']
    ) then
        return false
    end
    end
end

--направление тренда по свечам тайм фрейма
function trendIsUp(table)
    if (table['lastCandleOpen'] < table['lastCandleClose']) then
        return true
    else if (table['lastCandleOpen'] > table['lastCandleClose']) then
        return false
    end
    end
end

--свеча над линией средней цены
function candleOverLine(candleTable, lineTable)
    if (
            candleTable['lastCandleOpen'] > lineTable['ave_price_red']
                    and candleTable['lastCandleClose'] > lineTable['ave_price_red']
                    --and candleTable['beforeLastCandleOpen'] > lineTable['ave_price_red']
                    --and candleTable['beforeLastCandleClose'] > lineTable['ave_price_red']
                    and candleTable['lastCandleClose'] > candleTable['lastCandleOpen']
                    and candleTable['lastCandleClose'] > candleTable['beforeLastCandleOpen']
                    and candleTable['lastCandleClose'] > candleTable['beforeLastCandleClose']
    ) then
        return true
    else if (
            candleTable['lastCandleOpen'] < lineTable['ave_price_red']
                    and candleTable['lastCandleClose'] < lineTable['ave_price_red']
                    --and candleTable['beforeLastCandleOpen'] < lineTable['ave_price_red']
                    --and candleTable['beforeLastCandleClose'] < lineTable['ave_price_red']
                    and candleTable['lastCandleClose'] < candleTable['lastCandleOpen']
                    and candleTable['lastCandleClose'] < candleTable['beforeLastCandleOpen']
                    and candleTable['lastCandleClose'] < candleTable['beforeLastCandleClose']
    ) then
        return false
    end
    end
end

function insertInTableCloseOrder()
    SetCell(TableInWindow, CountOfLines, 5, tostring(getInfoParam("SERVERTIME")))
    SetCell(TableInWindow, CountOfLines, 6, tostring(lastTradePriceUser))
    if operation == 'B' then
        SetCell(TableInWindow, CountOfLines, 7, tostring(round((priceForGetProfit - lastTradePriceUser), roundVar)))
    else
        SetCell(TableInWindow, CountOfLines, 7, tostring(round((lastTradePriceUser - priceForGetProfit), roundVar)))
    end
end


-- функция записывает в лог строчку с временем и датой
function myLog(str)
    if f==nil then return end

    local current_time=os.time()--tonumber(timeformat(getInfoParam("SERVERTIME"))) -- помещене в переменную времени сервера в формате HHMMSS
    if (current_time-g_previous_time)>1 then -- если текущая запись произошла позже 1 секунды, чем предыдущая
        f:write("\n") -- добавляем пустую строку для удобства чтения
    end
    g_previous_time = current_time

    f:write('\n'..os.date().."; ".. str .. ";\n")

    if str:find("Script Stopped") ~= nil then
        f:write("======================================================================================================================\n\n")
        f:write("======================================================================================================================\n")
    end
    f:flush() -- Сохраняет изменения в файле
end